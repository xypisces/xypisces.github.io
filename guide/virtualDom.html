<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>虚拟DOM原理 | 前端进阶指南</title>
    <meta name="description" content="可能是全网最给力的前端面试项目">
    <link rel="icon" href="/logo.svg">
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/icons/apple-touch-icon-152x152.png">
  <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#3eaf7c">
  <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
  <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/assets/css/0.styles.37cec0f7.css" as="style"><link rel="preload" href="/assets/js/app.0d9a6c67.js" as="script"><link rel="preload" href="/assets/js/3.95546f60.js" as="script"><link rel="preload" href="/assets/js/63.d119457b.js" as="script"><link rel="preload" href="/assets/js/6.4cd0594d.js" as="script"><link rel="prefetch" href="/assets/js/10.dedc8522.js"><link rel="prefetch" href="/assets/js/11.5b4cc777.js"><link rel="prefetch" href="/assets/js/12.e2c9f81b.js"><link rel="prefetch" href="/assets/js/13.1fc44449.js"><link rel="prefetch" href="/assets/js/14.cf4f4b55.js"><link rel="prefetch" href="/assets/js/15.270eba0e.js"><link rel="prefetch" href="/assets/js/16.ef74a78b.js"><link rel="prefetch" href="/assets/js/17.1c47a12f.js"><link rel="prefetch" href="/assets/js/18.1df5685d.js"><link rel="prefetch" href="/assets/js/19.f70a2ac0.js"><link rel="prefetch" href="/assets/js/20.e879dc90.js"><link rel="prefetch" href="/assets/js/21.5a926cff.js"><link rel="prefetch" href="/assets/js/22.5b6133f5.js"><link rel="prefetch" href="/assets/js/23.2307e17d.js"><link rel="prefetch" href="/assets/js/24.0b4ca3fb.js"><link rel="prefetch" href="/assets/js/25.396d1bea.js"><link rel="prefetch" href="/assets/js/26.e7e99010.js"><link rel="prefetch" href="/assets/js/27.2c8eff5b.js"><link rel="prefetch" href="/assets/js/28.b3721381.js"><link rel="prefetch" href="/assets/js/29.4ee9e273.js"><link rel="prefetch" href="/assets/js/30.96e23a70.js"><link rel="prefetch" href="/assets/js/31.3897f0f2.js"><link rel="prefetch" href="/assets/js/32.b6695009.js"><link rel="prefetch" href="/assets/js/33.e72a9bca.js"><link rel="prefetch" href="/assets/js/34.acc0fce3.js"><link rel="prefetch" href="/assets/js/35.b3d2209d.js"><link rel="prefetch" href="/assets/js/36.7448ff30.js"><link rel="prefetch" href="/assets/js/37.c05aaa70.js"><link rel="prefetch" href="/assets/js/38.e31eb3fd.js"><link rel="prefetch" href="/assets/js/39.991adad7.js"><link rel="prefetch" href="/assets/js/4.3031f9ca.js"><link rel="prefetch" href="/assets/js/40.92642e40.js"><link rel="prefetch" href="/assets/js/41.e91e7591.js"><link rel="prefetch" href="/assets/js/42.de9fc619.js"><link rel="prefetch" href="/assets/js/43.e3989508.js"><link rel="prefetch" href="/assets/js/44.eda98159.js"><link rel="prefetch" href="/assets/js/45.984f2d02.js"><link rel="prefetch" href="/assets/js/46.0a0a9ce4.js"><link rel="prefetch" href="/assets/js/47.eeae3197.js"><link rel="prefetch" href="/assets/js/48.f248f653.js"><link rel="prefetch" href="/assets/js/49.4f8391f0.js"><link rel="prefetch" href="/assets/js/5.2b17e615.js"><link rel="prefetch" href="/assets/js/50.873d7cd3.js"><link rel="prefetch" href="/assets/js/51.e0ed221d.js"><link rel="prefetch" href="/assets/js/52.ac213d7d.js"><link rel="prefetch" href="/assets/js/53.eb3843ab.js"><link rel="prefetch" href="/assets/js/54.98dee885.js"><link rel="prefetch" href="/assets/js/55.b56060f2.js"><link rel="prefetch" href="/assets/js/56.18fac792.js"><link rel="prefetch" href="/assets/js/57.0cacb87a.js"><link rel="prefetch" href="/assets/js/58.63d5e406.js"><link rel="prefetch" href="/assets/js/59.afe7413f.js"><link rel="prefetch" href="/assets/js/60.33ce0ce5.js"><link rel="prefetch" href="/assets/js/61.fa36e213.js"><link rel="prefetch" href="/assets/js/62.80c469c6.js"><link rel="prefetch" href="/assets/js/64.6c50a1b4.js"><link rel="prefetch" href="/assets/js/65.1cdb1284.js"><link rel="prefetch" href="/assets/js/66.1e54442d.js"><link rel="prefetch" href="/assets/js/67.fce15a75.js"><link rel="prefetch" href="/assets/js/68.6691fa48.js"><link rel="prefetch" href="/assets/js/69.f3cb3ef8.js"><link rel="prefetch" href="/assets/js/7.fc6e0aed.js"><link rel="prefetch" href="/assets/js/70.4463ac0f.js"><link rel="prefetch" href="/assets/js/8.15b6fc71.js"><link rel="prefetch" href="/assets/js/9.9b1ee54d.js"><link rel="prefetch" href="/assets/js/vendors~notification.b8581b7d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.37cec0f7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端进阶指南</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/guide/" class="nav-link router-link-active">指南</a></div> <a href="https://github.com/xypisces/front-end-interview" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/guide/" class="nav-link router-link-active">指南</a></div> <a href="https://github.com/xypisces/front-end-interview" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前言</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/" class="sidebar-link">指南使用手册</a></li><li><a href="/guide/preface.html" class="sidebar-link">为什么会有这个项目</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>面试技巧</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/resume.html" class="sidebar-link">面试官到底想看什么样的简历？</a></li><li><a href="/guide/project.html" class="sidebar-link">面试回答问题的技巧</a></li><li><a href="/guide/hr.html" class="sidebar-link">如何通过HR面</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>推荐</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/book.html" class="sidebar-link">书籍/课程推荐</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/htmlBasic.html" class="sidebar-link">HTML基础</a></li><li><a href="/guide/cssBasic.html" class="sidebar-link">CSS基础</a></li><li><a href="/guide/jsBasic.html" class="sidebar-link">JavaScript基础</a></li><li><a href="/guide/browser.html" class="sidebar-link">浏览器与新技术</a></li><li><a href="/guide/dom.html" class="sidebar-link">DOM</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端基础笔试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/httpWritten.html" class="sidebar-link">HTTP笔试部分</a></li><li><a href="/guide/jsWritten.html" class="sidebar-link">JavaScript笔试部分</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端原理详解</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/hoisting.html" class="sidebar-link">JavaScript的『预解释』与『变量提升』</a></li><li><a href="/guide/eventLoop.html" class="sidebar-link">Event Loop详解</a></li><li><a href="/guide/immutable.html" class="sidebar-link">实现不可变数据</a></li><li><a href="/guide/memory.html" class="sidebar-link">JavaScript内存管理</a></li><li><a href="/guide/deepclone.html" class="sidebar-link">实现深克隆</a></li><li><a href="/guide/event.html" class="sidebar-link">如何实现一个Event</a></li><li><a href="/guide/mechanism.html" class="sidebar-link">JavaScript的运行机制</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>数据结构与算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/algorithm.html" class="sidebar-link">算法面试题</a></li><li><a href="/guide/string.html" class="sidebar-link">字符串类面试题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/framework.html" class="sidebar-link">关于前端框架的面试须知</a></li><li><a href="/guide/vue.html" class="sidebar-link">Vue面试题</a></li><li><a href="/guide/react.html" class="sidebar-link">React面试题</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>框架原理详解</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/virtualDom.html" class="active sidebar-link">虚拟DOM原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/guide/virtualDom.html#什么是virtual-dom" class="sidebar-link">什么是Virtual DOM</a></li><li class="sidebar-sub-header"><a href="/guide/virtualDom.html#为什么需要virtual-dom" class="sidebar-link">为什么需要Virtual DOM</a></li><li class="sidebar-sub-header"><a href="/guide/virtualDom.html#virtual-dom的关键要素" class="sidebar-link">Virtual DOM的关键要素</a></li><li class="sidebar-sub-header"><a href="/guide/virtualDom.html#virtual-dom的优化" class="sidebar-link">Virtual DOM的优化</a></li></ul></li><li><a href="/guide/devsProxy.html" class="sidebar-link">Proxy比defineproperty优劣对比?</a></li><li><a href="/guide/setState.html" class="sidebar-link">setState到底是异步的还是同步的?</a></li><li><a href="/guide/router.html" class="sidebar-link">前端路由的实现</a></li><li><a href="/guide/redux.html" class="sidebar-link">redux原理全解</a></li><li><a href="/guide/fiber.html" class="sidebar-link">React Fiber 架构解析</a></li><li><a href="/guide/abstract.html" class="sidebar-link">React组件复用指南</a></li><li><a href="/guide/reactHook.html" class="sidebar-link">React-hooks 抽象组件</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架实战技巧</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能优化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工程化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工程化原理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>安全</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="虚拟dom原理"><a href="#虚拟dom原理" aria-hidden="true" class="header-anchor">#</a> 虚拟DOM原理</h1> <blockquote><p>写完之后才发现了一篇百度EFE的好文,大家可以移步<a href="https://efe.baidu.com/blog/the-inner-workings-of-virtual-dom/" target="_blank" rel="noopener noreferrer">Vitual DOM 的内部工作原理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h2 id="什么是virtual-dom"><a href="#什么是virtual-dom" aria-hidden="true" class="header-anchor">#</a> 什么是Virtual DOM</h2> <p>Virtual DOM是对DOM的抽象,本质上是JavaScript对象,这个对象就是更加轻量级的对DOM的描述.</p> <p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/1b6e845647c60b0ce00ec91f679ec6cf.png" alt="2019-07-27-17-02-23"></p> <h2 id="为什么需要virtual-dom"><a href="#为什么需要virtual-dom" aria-hidden="true" class="header-anchor">#</a> 为什么需要Virtual DOM</h2> <p>既然我们已经有了DOM,为什么还需要额外加一层抽象?</p> <p>首先,我们都知道在前端性能优化的一个秘诀就是尽可能少地操作DOM,不仅仅是DOM相对较慢,更因为频繁变动DOM会造成浏览器的回流或者重回,这些都是性能的杀手,因此我们需要这一层抽象,在patch过程中尽可能地一次性将差异更新到DOM中,这样保证了DOM不会出现性能很差的情况.</p> <p>其次,现代前端框架的一个基本要求就是无须手动操作DOM,一方面是因为手动操作DOM无法保证程序性能,多人协作的项目中如果review不严格,可能会有开发者写出性能较低的代码,另一方面更重要的是省略手动DOM操作可以大大提高开发效率.</p> <p>最后,也是Virtual DOM最初的目的,就是更好的跨平台,比如Node.js就没有DOM,如果想实现SSR(服务端渲染),那么一个方式就是借助Virtual DOM,因为Virtual DOM本身是JavaScript对象.</p> <h2 id="virtual-dom的关键要素"><a href="#virtual-dom的关键要素" aria-hidden="true" class="header-anchor">#</a> Virtual DOM的关键要素</h2> <h3 id="virtual-dom的创建"><a href="#virtual-dom的创建" aria-hidden="true" class="header-anchor">#</a> Virtual DOM的创建</h3> <p>我们已经知道Virtual DOM是对真实DOM的抽象,根据不同的需求我们可以做出不同的抽象,比如<code>snabbdom.js</code>的抽象方式是这样的.</p> <p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/1806365ed29745b7411d4fa3c7a13a80.png" alt="2019-07-28-00-19-08"></p> <p>当然,snabbdom.js由于是面向生产环境的库,所以做了大量的抽象各种,我们由于仅仅作为教程理解,因此采用最简单的抽象方法:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  type<span class="token punctuation">,</span> <span class="token comment">// String，DOM 节点的类型，如 'div'</span>
  data<span class="token punctuation">,</span> <span class="token comment">// Object，包括 props，style等等 DOM 节点的各种属性</span>
  children <span class="token comment">// Array，子节点</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在明确了我们抽象的Virtual DOM构造之后,我们就需要一个函数来创建Virtual DOM.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * 生成 vnode
 * @param  {String} type     类型，如 'div'
 * @param  {String} key      key vnode的唯一id
 * @param  {Object} data     data，包括属性，事件等等
 * @param  {Array} children  子 vnode
 * @param  {String} text     文本
 * @param  {Element} elm     对应的 dom
 * @return {Object}          vnode
 */</span>
<span class="token keyword">function</span> <span class="token function">vnode</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> key<span class="token punctuation">,</span> data<span class="token punctuation">,</span> children<span class="token punctuation">,</span> text<span class="token punctuation">,</span> elm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token punctuation">{</span>
    __type<span class="token punctuation">:</span> <span class="token constant">VNODE_TYPE</span><span class="token punctuation">,</span>
    type<span class="token punctuation">,</span> key<span class="token punctuation">,</span> data<span class="token punctuation">,</span> children<span class="token punctuation">,</span> text<span class="token punctuation">,</span> elm
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> element
<span class="token punctuation">}</span>
</code></pre></div><p>这个函数很简单,接受一定的参数,再根据这些参数返回一个对象,这个对象就是DOM的抽象.</p> <h3 id="virtual-dom-tree的创建"><a href="#virtual-dom-tree的创建" aria-hidden="true" class="header-anchor">#</a> Virtual DOM Tree的创建</h3> <p>上面我们已经声明了一个vnode函数用于单个Virtual DOM的创建工作,但是我们都知道DOM其实是一个Tree,我们接下来要做的就是声明一个函数用于创建DOM Tree的抽象 -- Virtual DOM Tree.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> config<span class="token punctuation">,</span> <span class="token operator">...</span>children</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">let</span> key <span class="token operator">=</span> <span class="token keyword">null</span>

  <span class="token comment">// 获取 key，填充 props 对象</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>config <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasValidKey</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      key <span class="token operator">=</span> <span class="token string">''</span> <span class="token operator">+</span> config<span class="token punctuation">.</span>key
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> propName <span class="token keyword">in</span> config<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>config<span class="token punctuation">,</span> propName<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token constant">RESERVED_PROPS</span><span class="token punctuation">[</span>propName<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        props<span class="token punctuation">[</span>propName<span class="token punctuation">]</span> <span class="token operator">=</span> config<span class="token punctuation">[</span>propName<span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token function">vnode</span><span class="token punctuation">(</span>
    type<span class="token punctuation">,</span>
    key<span class="token punctuation">,</span>
    props<span class="token punctuation">,</span>
    <span class="token function">flattenArray</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">c</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">isPrimitive</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">vnode</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token punctuation">:</span> c
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="virtual-dom-的更新"><a href="#virtual-dom-的更新" aria-hidden="true" class="header-anchor">#</a> Virtual DOM 的更新</h3> <p>Virtual DOM 归根到底是JavaScript对象,我们得想办法将Virtual DOM与真实的DOM对应起来,也就是说,需要我们声明一个函数,此函数可以将vnode转化为真实DOM.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createElm</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> insertedVnodeQueue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> data <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data
  <span class="token keyword">let</span> i
  <span class="token comment">// 省略 hook 调用</span>
  <span class="token keyword">let</span> children <span class="token operator">=</span> vnode<span class="token punctuation">.</span>children
  <span class="token keyword">let</span> type <span class="token operator">=</span> vnode<span class="token punctuation">.</span>type

  <span class="token comment">/// 根据 type 来分别生成 DOM</span>
  <span class="token comment">// 处理 comment</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> <span class="token string">'comment'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>text <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      vnode<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">''</span>
    <span class="token punctuation">}</span>
    vnode<span class="token punctuation">.</span>elm <span class="token operator">=</span> api<span class="token punctuation">.</span><span class="token function">createComment</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 处理其它 type</span>
  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> elm <span class="token operator">=</span> vnode<span class="token punctuation">.</span>elm <span class="token operator">=</span> data<span class="token punctuation">.</span>ns
      <span class="token operator">?</span> api<span class="token punctuation">.</span><span class="token function">createElementNS</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>ns<span class="token punctuation">,</span> type<span class="token punctuation">)</span>
      <span class="token punctuation">:</span> api<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span>

    <span class="token comment">// 调用 create hook</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cbs<span class="token punctuation">.</span>create<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> cbs<span class="token punctuation">.</span>create<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>emptyNode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>

    <span class="token comment">// 分别处理 children 和 text。</span>
    <span class="token comment">// 这里隐含一个逻辑：vnode 的 children 和 text 不会／应该同时存在。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isArray</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 递归 children，保证 vnode tree 中每个 vnode 都有自己对应的 dom；</span>
      <span class="token comment">// 即构建 vnode tree 对应的 dom tree。</span>
      children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">ch</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        ch <span class="token operator">&amp;&amp;</span> api<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> <span class="token function">createElm</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isPrimitive</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      api<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> api<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 调用 create hook；为 insert hook 填充 insertedVnodeQueue。</span>
    i <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>hook
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      i<span class="token punctuation">.</span>create <span class="token operator">&amp;&amp;</span> i<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>emptyNode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
      i<span class="token punctuation">.</span>insert <span class="token operator">&amp;&amp;</span> insertedVnodeQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 处理 text（text的 type 是空）</span>
  <span class="token keyword">else</span> <span class="token punctuation">{</span>
    vnode<span class="token punctuation">.</span>elm <span class="token operator">=</span> api<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> vnode<span class="token punctuation">.</span>elm
<span class="token punctuation">}</span>
</code></pre></div><p>上述函数其实工作很简单,就是根据 type 生成对应的 DOM，把 data 里定义的 各种属性设置到 DOM 上.</p> <h3 id="virtual-dom-的diff"><a href="#virtual-dom-的diff" aria-hidden="true" class="header-anchor">#</a> Virtual DOM 的diff</h3> <p>Virtual DOM 的 diff才是整个Virtual DOM 中最难理解也最核心的部分,diff的目的就是比较新旧Virtual DOM Tree找出差异并更新.</p> <p>可见diff是直接影响Virtual DOM 性能的关键部分.</p> <p>要比较Virtual DOM Tree的差异,理论上的时间复杂度高达O(n^3),这是一个奇高无比的时间复杂度,很显然选择这种低效的算法是无法满足我们对程序性能的基本要求的.</p> <p>好在我们实际开发中,很少会出现跨层级的DOM变更,通常情况下的DOM变更是同级的,因此在现代的各种Virtual DOM库都是只比较同级差异,在这种情况下我们的时间复杂度是O(n).</p> <p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/63e704710ceda7b3e14c586eb51b36ae.png" alt="2019-07-29-15-12-28"></p> <p>那么我们接下来需要实现一个函数,进行具体的diff运算,函数updateChildren的核心算法如下:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 遍历 oldCh 和 newCh 来比较和更新</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>oldStartIdx <span class="token operator">&lt;=</span> oldEndIdx <span class="token operator">&amp;&amp;</span> newStartIdx <span class="token operator">&lt;=</span> newEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 1⃣️ 首先检查 4 种情况，保证 oldStart/oldEnd/newStart/newEnd</span>
      <span class="token comment">// 这 4 个 vnode 非空，左侧的 vnode 为空就右移下标，右侧的 vnode 为空就左移 下标。</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartVnode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        oldStartVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">++</span>oldStartIdx<span class="token punctuation">]</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEndVnode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        oldEndVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">--</span>oldEndIdx<span class="token punctuation">]</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>newStartVnode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>newEndVnode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        newEndVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">--</span>newEndIdx<span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
      <span class="token comment">/**
       * 2⃣️ 然后 oldStartVnode/oldEndVnode/newStartVnode/newEndVnode 两两比较，
       * 对有相同 vnode 的 4 种情况执行对应的 patch 逻辑。
       * - 如果同 start 或同 end 的两个 vnode 是相同的（情况 1 和 2），
       *   说明不用移动实际 dom，直接更新 dom 属性／children 即可；
       * - 如果 start 和 end 两个 vnode 相同（情况 3 和 4），
       *   那说明发生了 vnode 的移动，同理我们也要移动 dom。
       */</span>
      <span class="token comment">// 1. 如果 oldStartVnode 和 newStartVnode 相同（key相同），执行 patch</span>
      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSameVnode</span><span class="token punctuation">(</span>oldStartVnode<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 不需要移动 dom</span>
        <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldStartVnode<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>
        oldStartVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">++</span>oldStartIdx<span class="token punctuation">]</span>
        newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 2. 如果 oldEndVnode 和 newEndVnode 相同，执行 patch</span>
      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSameVnode</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">,</span> newEndVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 不需要移动 dom</span>
        <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">,</span> newEndVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>
        oldEndVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">--</span>oldEndIdx<span class="token punctuation">]</span>
        newEndVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">--</span>newEndIdx<span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 3. 如果 oldStartVnode 和 newEndVnode 相同，执行 patch</span>
      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSameVnode</span><span class="token punctuation">(</span>oldStartVnode<span class="token punctuation">,</span> newEndVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldStartVnode<span class="token punctuation">,</span> newEndVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>
        <span class="token comment">// 把获得更新后的 (oldStartVnode/newEndVnode) 的 dom 右移，移动到</span>
        <span class="token comment">// oldEndVnode 对应的 dom 的右边。为什么这么右移？</span>
        <span class="token comment">// （1）oldStartVnode 和 newEndVnode 相同，显然是 vnode 右移了。</span>
        <span class="token comment">// （2）若 while 循环刚开始，那移到 oldEndVnode.elm 右边就是最右边，是合理的；</span>
        <span class="token comment">// （3）若循环不是刚开始，因为比较过程是两头向中间，那么两头的 dom 的位置已经是</span>
        <span class="token comment">//     合理的了，移动到 oldEndVnode.elm 右边是正确的位置；</span>
        <span class="token comment">// （4）记住，oldVnode 和 vnode 是相同的才 patch，且 oldVnode 自己对应的 dom</span>
        <span class="token comment">//     总是已经存在的，vnode 的 dom 是不存在的，直接复用 oldVnode 对应的 dom。</span>
        api<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>parentElm<span class="token punctuation">,</span> oldStartVnode<span class="token punctuation">.</span>elm<span class="token punctuation">,</span> api<span class="token punctuation">.</span><span class="token function">nextSibling</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span><span class="token punctuation">)</span>
        oldStartVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">++</span>oldStartIdx<span class="token punctuation">]</span>
        newEndVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">--</span>newEndIdx<span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 4. 如果 oldEndVnode 和 newStartVnode 相同，执行 patch</span>
      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSameVnode</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldEndVnode<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>
        <span class="token comment">// 这里是左移更新后的 dom，原因参考上面的右移。</span>
        api<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>parentElm<span class="token punctuation">,</span> oldEndVnode<span class="token punctuation">.</span>elm<span class="token punctuation">,</span> oldStartVnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span>
        oldEndVnode <span class="token operator">=</span> oldCh<span class="token punctuation">[</span><span class="token operator">--</span>oldEndIdx<span class="token punctuation">]</span>
        newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// 3⃣️ 最后一种情况：4 个 vnode 都不相同，那么我们就要</span>
      <span class="token comment">// 1. 从 oldCh 数组建立 key --&gt; index 的 map。</span>
      <span class="token comment">// 2. 只处理 newStartVnode （简化逻辑，有循环我们最终还是会处理到所有 vnode），</span>
      <span class="token comment">//    以它的 key 从上面的 map 里拿到 index；</span>
      <span class="token comment">// 3. 如果 index 存在，那么说明有对应的 old vnode，patch 就好了；</span>
      <span class="token comment">// 4. 如果 index 不存在，那么说明 newStartVnode 是全新的 vnode，直接</span>
      <span class="token comment">//    创建对应的 dom 并插入。</span>
      <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果 oldKeyToIdx 不存在，创建 old children 中 vnode 的 key 到 index 的</span>
        <span class="token comment">// 映射，方便我们之后通过 key 去拿下标。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldKeyToIdx <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          oldKeyToIdx <span class="token operator">=</span> <span class="token function">createKeyToOldIdx</span><span class="token punctuation">(</span>oldCh<span class="token punctuation">,</span> oldStartIdx<span class="token punctuation">,</span> oldEndIdx<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 尝试通过 newStartVnode 的 key 去拿下标</span>
        idxInOld <span class="token operator">=</span> oldKeyToIdx<span class="token punctuation">[</span>newStartVnode<span class="token punctuation">.</span>key<span class="token punctuation">]</span>
        <span class="token comment">// 下标不存在，说明 newStartVnode 是全新的 vnode。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>idxInOld <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 那么为 newStartVnode 创建 dom 并插入到 oldStartVnode.elm 的前面。</span>
          api<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>parentElm<span class="token punctuation">,</span> <span class="token function">createElm</span><span class="token punctuation">(</span>newStartVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span><span class="token punctuation">,</span> oldStartVnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span>
          newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 下标存在，说明 old children 中有相同 key 的 vnode，</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
          elmToMove <span class="token operator">=</span> oldCh<span class="token punctuation">[</span>idxInOld<span class="token punctuation">]</span>
          <span class="token comment">// 如果 type 不同，没办法，只能创建新 dom；</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>elmToMove<span class="token punctuation">.</span>type <span class="token operator">!==</span> newStartVnode<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            api<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>parentElm<span class="token punctuation">,</span> <span class="token function">createElm</span><span class="token punctuation">(</span>newStartVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span><span class="token punctuation">,</span> oldStartVnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token comment">// type 相同（且key相同），那么说明是相同的 vnode，执行 patch。</span>
          <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">patchVnode</span><span class="token punctuation">(</span>elmToMove<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>
            oldCh<span class="token punctuation">[</span>idxInOld<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">undefined</span>
            api<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>parentElm<span class="token punctuation">,</span> elmToMove<span class="token punctuation">.</span>elm<span class="token punctuation">,</span> oldStartVnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 上面的循环结束后（循环条件有两个），处理可能的未处理到的 vnode。</span>
    <span class="token comment">// 如果是 new vnodes 里有未处理的（oldStartIdx &gt; oldEndIdx</span>
    <span class="token comment">// 说明 old vnodes 先处理完毕）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldStartIdx <span class="token operator">&gt;</span> oldEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      before <span class="token operator">=</span> newCh<span class="token punctuation">[</span>newEndIdx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token punctuation">:</span> newCh<span class="token punctuation">[</span>newEndIdx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>elm
      <span class="token function">addVnodes</span><span class="token punctuation">(</span>parentElm<span class="token punctuation">,</span> before<span class="token punctuation">,</span> newCh<span class="token punctuation">,</span> newStartIdx<span class="token punctuation">,</span> newEndIdx<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 相反，如果 old vnodes 有未处理的，删除 （为处理 vnodes 对应的） 多余的 dom。</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>newStartIdx <span class="token operator">&gt;</span> newEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">removeVnodes</span><span class="token punctuation">(</span>parentElm<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> oldStartIdx<span class="token punctuation">,</span> oldEndIdx<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>我们可以假设有旧的Vnode数组和新的Vnode数组这两个数组,而且有四个变量充当指针分别指到两个数组的头尾.</p> <p>重复下面的对比过程，直到两个数组中任一数组的头指针超过尾指针，循环结束
:</p> <ul><li>头头对比: 对比两个数组的头部，如果找到，把新节点patch到旧节点，头指针后移</li> <li>尾尾对比: 对比两个数组的尾部，如果找到，把新节点patch到旧节点，尾指针前移</li> <li>旧尾新头对比: 交叉对比，旧尾新头，如果找到，把新节点patch到旧节点，旧尾指针前移，新头指针后移</li> <li>旧头新尾对比: 交叉对比，旧头新尾，如果找到，把新节点patch到旧节点，新尾指针前移，旧头指针后移</li> <li>利用key对比: 用新指针对应节点的key去旧数组寻找对应的节点,这里分三种情况,当没有对应的key，那么创建新的节点,如果有key并且是相同的节点，把新节点patch到旧节点,如果有key但是不是相同的节点，则创建新节点</li></ul> <p>我们假设有新旧两个数组:</p> <ul><li>旧数组: <code>[1, 2, 3, 4, 5]</code></li> <li>新数组: <code>[1, 4, 6, 1000, 100, 5]</code></li></ul> <p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/785abcf36f3265f86c97bce5ecc5e4af.png" alt="初始化"></p> <p>首先我们进行头头对比,新旧数组的头部都是<code>1</code>,因此将双方的头部指针后移.</p> <p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/62e35ec86edba1629f211da0227b9a81.png" alt="头头对比"></p> <p>我们继续头头对比,但是<code>2 !== 4</code>导致对比失败,我进入尾尾对比,<code>5 === 5</code>,那么尾部指针则可前移.</p> <p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/2cd6b6df3ad521f9796d4dab2fa2cb9f.png" alt="尾尾对比"></p> <p>现在进入新的循环,头头对比<code>2 !== 4</code>,尾尾对比<code>4 !== 100</code>,此时进入交叉对比,先进行旧尾新头对比,即<code>4 === 4</code>,旧尾前移且新头后移.</p> <p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/4c711d813dbf192cb764a8b0ec6807d0.png" alt="旧尾新头对比"></p> <p>接着再进入一个轮新的循环,头头对比<code>2 !== 6</code>,尾尾对比<code>3 !== 100</code>,交叉对比<code>2 != 100 3 != 6</code>,四种对比方式全部不符合,如果这个时候需要通过key去对比,然后将新头指针后移</p> <p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/a48eec6e6c703d92ee1fb9da87cf778a.png" alt="全部不符合靠key对比"></p> <p>继续重复上述对比的循环方式直至任一数组的头指针超过尾指针，循环结束.</p> <p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/d83286f071ccfaf5ba3542c3e2818803.png" alt="2019-07-29-19-06-41"></p> <p>在上述循环结束后,两个数组中可能存在未遍历完的情况:
循环结束后，</p> <ul><li><p>先对比旧数组的头尾指针，如果旧数组遍历完了（可能新数组没遍历完，有漏添加的问题），添加新数组中漏掉的节点</p> <p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/8cb8cba251b846cfade826424304b0d9.png" alt="添加遗漏节点"></p></li> <li><p>再对比新数组的头尾指针，如果新数组遍历完了（可能旧数组没遍历完，有漏删除的问题），删除旧数组中漏掉的节点</p> <p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/bdafefe8bbf56ab921ce8af719479807.png" alt="删除冗余节点"></p></li></ul> <h2 id="virtual-dom的优化"><a href="#virtual-dom的优化" aria-hidden="true" class="header-anchor">#</a> Virtual DOM的优化</h2> <p>上一节我们的Virtual DOM实现是参考了snabbdom.js的实现,当然Vue.js也同样参考了snabbdom.js,我们省略了大量边缘状态和svg等相关的代码,仅仅实现了其核心部分.</p> <p>snabbdom.js已经是社区内主流的Virtual DOM实现了,vue 2.0阶段与snabbdom.js一样都采用了上面讲解的「双端比较算法」,那么有没有一些优化方案可以使其更快?</p> <p>其实，社区内有更快的算法，例如inferno.js就号称最快react-like框架(虽然inferno.js性能强悍的原因不仅仅是算法,但是其diff算法的确是目前最快的),而vue 3.0就会借鉴inferno.js的算法进行优化.</p> <p>我们可以等到Vue 3.0发布后再一探究竟,具体的优化思想可以先参考<a href="https://github.com/NervJS/nerv/issues/3" target="_blank" rel="noopener noreferrer">diff 算法原理概述<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>,其中一个核心的思想就是利用LIS(最长递增子序列)的思想做动态规划,找到最小的移动次数.</p> <p>例如以下两个新旧数组,React的算法会把 a, b, c 移动到他们的相应的位置 + 1共三步操作,而inferno.js则是直接将d移动到最前端这一步操作.</p> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token operator">*</span> <span class="token constant">A</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>a b c d<span class="token punctuation">]</span>
 <span class="token operator">*</span> <span class="token constant">B</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>d a b c<span class="token punctuation">]</span>
</code></pre></div><hr> <p>参考文章:</p> <ul><li><a href="https://github.com/NervJS/nerv/issues/3" target="_blank" rel="noopener noreferrer">diff 算法原理概述<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/snabbdom/snabbdom/blob/master/src/snabbdom.ts" target="_blank" rel="noopener noreferrer">snabbdom<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/creeperyang/blog/issues/33" target="_blank" rel="noopener noreferrer">解析snabbdom源码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/yelouafi/petit-dom/blob/5412b18ad26108762ebf5624ac1c5bd70c578e57/src/vdom.js#L690" target="_blank" rel="noopener noreferrer">nerv<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <hr></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/xypisces/front-end-interview/edit/master/packages/docs/docs/guide/virtualDom.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/guide/react.html" class="prev">
          React面试题
        </a></span> <span class="next"><a href="/guide/devsProxy.html">
          Proxy比defineproperty优劣对比?
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.0d9a6c67.js" defer></script><script src="/assets/js/3.95546f60.js" defer></script><script src="/assets/js/63.d119457b.js" defer></script><script src="/assets/js/6.4cd0594d.js" defer></script>
  </body>
</html>
